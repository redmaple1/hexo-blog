---
title: 基础加固-建造者模式
date: 2019-07-09 11:30:00
tags: 
    - 基础
    - 设计模式
categories: 设计模式
---
&ensp;&ensp;&ensp;上篇我们复习了工厂模式，这节我们来看一下创建型设计模式的另一种模式--建造者模式。  
## 一、定义  
&ensp;&ensp;&ensp;建造者模式是指将一个复杂对象的构建和它的表示分离，使同样的构建过程可以构建不同的表示。用户只需要指定需要建造的类型就可以得到它们，建造过程以及细节并不需要知道。适用于那些创建流程固定，但顺序不一定固定的对象。如果一个对象有非常复杂的内部结构，即有很多属性，我们想把这种复杂对象的创建和使用进行分离，我们可以使用建造者模式。这样看定义难免抽象，接下来我们一起编写代码来加深对工厂模式的理解。
### 1.代码实现
&ensp;&ensp;&ensp;首先我们有一个类Game，有名称、简介、制作团队、宣传视频、社区几个属性。代码如下：
{% codeblock Game.java lang:java %}
public class Game {
    private String name;
    private String introduce;
    private String team;
    private String video;
    private String community;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIntroduce() {
        return introduce;
    }

    public void setIntroduce(String introduce) {
        this.introduce = introduce;
    }

    public String getTeam() {
        return team;
    }

    public void setTeam(String team) {
        this.team = team;
    }

    public String getVideo() {
        return video;
    }

    public void setVideo(String video) {
        this.video = video;
    }

    public String getCommunity() {
        return community;
    }

    public void setCommunity(String community) {
        this.community = community;
    }

    @Override
    public String toString() {
        return "Game{" +
                "name='" + name + '\'' +
                ", introduce='" + introduce + '\'' +
                ", team='" + team + '\'' +
                ", video='" + video + '\'' +
                ", community='" + community + '\'' +
                '}';
    }
}
{% endcodeblock %}  

我们创建一个抽象类GameBuilder，其中定义了创建各个属性的方法和生成Game对象的方法，代码如下：
{% codeblock GameBuilder.java lang:java %}
public abstract class GameBuilder {
    public abstract void buildName(String name);

    public abstract void buildIntroduce(String introduce);

    public abstract void buildTeam(String team);

    public abstract void buildVideo(String video);

    public abstract void buildCommunity(String community);

    public abstract Game makeGame();
}
{% endcodeblock %}  

接下来我们要创建具体的builder实现，比如我们要创建一个动作游戏的建造者ActionGameBuilder，我们只需要继承上面的抽象builder，重写里面的方法即可，代码如下：
{% codeblock ActionGameBuilder.java lang:java %}
public class ActionGameBuilder extends GameBuilder {
    Game game = new Game();

    @Override
    public void buildName(String name) {
        game.setName(name);
    }

    @Override
    public void buildIntroduce(String introduce) {
        game.setIntroduce(introduce);
    }

    @Override
    public void buildTeam(String team) {
        game.setTeam(team);
    }

    @Override
    public void buildVideo(String video) {
        game.setVideo(video);
    }

    @Override
    public void buildCommunity(String community) {
        game.setCommunity(community);
    }

    @Override
    public Game makeGame() {
        return game;
    }
}
{% endcodeblock %}  

其实现在我们已经可以使用我们创建的builder进行创建游戏了，不过这里可以定义一个管理角色的对象，对builder进行管理，用它来进行管理对象的创建，这里我们定义一个游戏经理类GameManager。
{% codeblock GameManager.java lang:java %}
public class GameManager {
    private GameBuilder gameBuilder;

    public void setGameBuilder(GameBuilder gameBuilder) {
        this.gameBuilder = gameBuilder;
    }

    public Game makeGame(String name, String introduce, String team, String video, String community) {
        gameBuilder.buildName(name);
        gameBuilder.buildIntroduce(introduce);
        gameBuilder.buildTeam(team);
        gameBuilder.buildVideo(video);
        gameBuilder.buildCommunity(community);
        return gameBuilder.makeGame();
    }

}
{% endcodeblock %}   
写到这里我们已经完成了一个标准的建造者模式代码，写一个测试类来测试一下。
{% codeblock Test.java lang:java %}
public class Test {
    public static void main(String[] args) {
        GameBuilder gameBuilder = new ActionGameBuilder();

        GameManager manager = new GameManager();
        manager.setGameBuilder(gameBuilder);

        Game game = manager.makeGame("游戏名称",
                "这是一个很好玩的动作游戏",
                "制作团队",
                "游戏宣传视频",
                "游戏社区");
        System.out.println(game);
    }
}
{% endcodeblock %}   
控制台可以看到创建的游戏信息。  
{% codeblock %}
Game{name='游戏名称', introduce='这是一个很好玩的动作游戏', team='制作团队', video='游戏宣传视频', community='游戏社区'}

Process finished with exit code 0
{% endcodeblock %}   

### 2.UML  
&ensp;&ensp;&ensp;我们可以看到标准的建造者模式的UML类图。  
<img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/design_pattern/BuilderStandardUML.png" width="50%" height="50%">   
我们测试时通过游戏经理和动作游戏建造者创建了含有较多属性的游戏类，并不关心创建的过程和顺序，有很好的封装性，使创建和使用分离，并且有很好的扩展性，建造类之间独立，在一定程度上解耦。




